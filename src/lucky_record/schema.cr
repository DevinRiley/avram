class LuckyRecord::Schema
  macro inherited
    FIELDS = [] of {name: Symbol, type: Object, nilable: Boolean}

    field :id, Int32
    field :created_at, Time
    field :updated_at, Time
  end

  def_equals @id

  macro table(table_name)
    {{yield}}
    setup {{table_name}}
  end

  macro setup(table_name)
    setup_initialize
    setup_db_mapping
    setup_getters
    setup_abstract_row_class({{table_name}})
    setup_abstract_changeset_class({{table_name}})
    setup_table_name({{table_name}})
  end

  macro setup_table_name(table_name)
    @@table_name = {{table_name}}
  end

  macro setup_initialize
    def initialize(
        {% for field in FIELDS %}
          @{{field[:name].id}} : {{LuckyRecord::Types::TYPE_MAPPINGS[field[:type]]}}{% if field[:nilable] %}?{% end %},
        {% end %}
      )
    end
  end

  macro setup_db_mapping
    DB.mapping({
      {% for field in FIELDS %}
        {{field[:name].id}}: {
          type: {{LuckyRecord::Types::TYPE_MAPPINGS[field[:type]]}},
          nilable: {{field[:nilable].id}},
        },
      {% end %}
    })
  end

  macro setup_abstract_row_class(table_name)
    abstract class BaseRows < LuckyRecord::Rows
      @@table_name = {{table_name}}
      @@schema_class = {{@type}}

      def field_names
        [
          {% for field in FIELDS %}
            {{field[:name]}},
          {% end %}
        ]
      end
    end
  end

  macro setup_abstract_changeset_class(table_name)
    abstract class BaseChangeset
      property? performed : Bool = false

      @record : {{@type}}?
      @params : Hash(String, String)
      @valid : Bool = true
      @errors = Hash(Symbol, Array(String)).new(Array(String).new)

      @@table_name = {{table_name}}

      def initialize(@params)
      end

      def initialize(@record, @params)
      end

      def valid? : Bool
        call
        @valid
      end

      def call
        # TODO add default validate_required for non-nilable fields
      end

      macro allow(*field_names)
        \{% for field_name in field_names %}
          def \{{field_name.id}}_param
            super
          end
        \{% end %}
      end

      def save : Bool
        @performed = true

        if valid?
          LuckyRecord::Repo.run do |db|
            db.exec "INSERT INTO #{@@table_name}(#{fields_for_insert}) VALUES(#{values_for_insert})"
          end
          true
        else
          false
        end
      end

      private def fields_for_insert
        non_autogenerated_fields.keys.join(", ")
      end

      private def values_for_insert
        non_autogenerated_fields.values.join(", ")
      end

      private def non_autogenerated_fields
        fields.reject do |key, _value|
          key == "id"
        end
      end

      private def fields
        {
          {% for field in FIELDS %}
            {{field[:name].id.stringify}} => escape_sql({{field[:name].id}}),
          {% end %}
        }.merge({"created_at" => escape_sql(Time.now), "updated_at" => escape_sql(Time.now)})
      end

      private def escape_sql(value : String | Time)
        PG::EscapeHelper.escape_literal(value.to_s)
      end

      private def escape_sql(value : Int32)
        value
      end

      private def escape_sql(value : Nil)
        "NULL"
      end

      def self.new_insert(params)
        new(params)
      end

      def self.new_insert(**params)
        params_with_stringified_keys = {} of String => String
        params.each do |key, value|
          params_with_stringified_keys[key.to_s] = value
        end

        new(params_with_stringified_keys)
      end

      def self.new_update(to record, with params)
        new(record, params)
      end

      {% for field in FIELDS %}
        def {{field[:name].id}}
          {{field[:name].id}}_param || @record.try &.{{field[:name].id}}
        end

        private def {{field[:name].id}}_param
          @params["{{field[:name].id}}"]?
        end

        def add_{{field[:name].id}}_error(message)
          @valid = false
          @errors[:{{field[:name].id}}]
          @errors[:{{field[:name].id}}] = (@errors[:{{field[:name].id}}] + [message]).uniq
        end

        def {{field[:name].id}}_errors
          @errors[:{{field[:name].id}}]
        end
      {% end %}
    end
  end

  macro setup_getters
    {% for field in FIELDS %}
      def {{field[:name].id}}
        {{ field[:type].id }}.parse @{{field[:name].id}}
      end
    {% end %}
  end

  macro field(name)
    field {{name}}, String
  end

  macro field(name, type, nilable = false)
    {% type = type.resolve %}
    {% if type == String %}
      {% type = LuckyRecord::StringType %}
    {% end %}
    {% if type == Time %}
      {% type = LuckyRecord::TimeType %}
    {% end %}
    {% if type == Int32 %}
      {% type = LuckyRecord::Int32Type %}
    {% end %}
    {% FIELDS << {name: name, type: type, nilable: nilable} %}
  end
end
